#!/usr/bin/env python
import os
import sys
import fnmatch
import shutil
import subprocess

# utility mode to convert GLSL to C string
if len(sys.argv) == 3 and sys.argv[1] == "file2str":
	print("const char * " + sys.argv[2] + ' = ');
	while s := sys.stdin.readline():
		s = s.replace('\\', "\\\\")
		s = s.replace('"', "\\\"")
		print("\"" + s.rstrip() + "\\n\"");
	print(';\n')
	sys.exit(0)

# config
target  = 'cplot'
libs    = 'z X11 Xi GL GLU GLEW pthread readline'

shaders = False # translate all .glsl files to .c code?
pch     = "pch.h" # pre-compiled header path or None

# name => [additional cc_flags, additional linker_flags]
variants = {
		"debug": ['-Og -DDEBUG -D_DEBUG -g', ''],
		"release": ['-O3 -s -DNDEBUG', '-s'],
		"profile": ['-O3 -s -DNDEBUG -pg', '-s -pg']
}

# use pkg-config to add pangocairo library
A = 'pkg-config --cflags pangocairo'.split()
res = subprocess.run(A, capture_output=True, text=True)
if res.returncode != 0: sys.exit("pkg-config failed!")
cc_flags = res.stdout.strip()
A = 'pkg-config --libs pangocairo'.split()
res = subprocess.run(A, capture_output=True, text=True)
if res.returncode != 0: sys.exit("pkg-config failed!")
lnk_flags = res.stdout.strip()
for v in variants:
	variants[v][0] += " " + cc_flags
	variants[v][1] += " " + lnk_flags

if len(sys.argv) == 2 and sys.argv[1] == "clean":
	if os.path.islink("build.ninja"): os.remove("build.ninja")
	if os.path.islink(target): os.remove(target)
	if shaders and os.path.exists("shaders.h"): os.remove("shaders.h")
	for variant in variants:
		d = "build_" + variant
		if os.path.exists(d): shutil.rmtree(d)
	sys.exit(0)

# create/update symlinks for current build variant
if len(sys.argv) > 1 and sys.argv[1] in variants:
	d = 'build_' + sys.argv[1]
	if os.path.islink("build.ninja"): os.remove("build.ninja")
	if os.path.islink(target): os.remove(target)
	if not os.path.exists("build.ninja"):
		os.symlink(d + "/build.ninja", "build.ninja")
	if not os.path.exists(target):
		os.symlink(d + "/"+target, target)
elif not os.path.lexists("build.ninja") and not os.path.lexists(target):
	os.symlink("build_debug/build.ninja", "build.ninja")
	os.symlink("build_debug/"+target, target)

# write the build.ninja files
for variant,flags in variants.items():
	base = "build_" + variant
	file = os.path.join(base, "build.ninja")
	if os.path.lexists(file): continue
	if not os.path.exists(base): os.mkdir(base)
	with open(file, "w") as f:
		stdout = sys.stdout
		sys.stdout = f
		
		cc_flags  = flags[0]
		lnk_flags = flags[1]

		PCH = "" if not pch else f" -I{base} -include {pch}.pch.h -Winvalid-pch"

		print(f"""#auto-generated by ./build, delete to regenerate.

builddir = {base}

cflags = -DUSE_PTHREADS $
  -Wall -Wextra -Wno-sign-compare -Wno-deprecated-declarations $
  -Wno-parentheses -Wno-misleading-indentation -Wno-class-memaccess $
  -Wno-variadic-macros -Wno-unused-parameter -Wno-unknown-pragmas $
  -Wno-implicit-fallthrough -Wno-missing-field-initializers $
  {cc_flags}

ccflags = $cflags -std=c++17 -Wno-reorder -fstrict-enums

rule gl
  command = ./build file2str $name <$in >$out
  description = \033[32mGL\033[m $in

rule cc
  command = g++ -MD -MF $out.dep $ccflags{PCH} -c $in -o $out
  depfile = $out.dep
  deps = gcc
  description = \033[32mCC\033[m $in

rule c
  command = gcc -MD -MF $out.dep $cflags -c $in -o $out
  depfile = $out.dep
  deps = gcc
  description = \033[32mC \033[m $in

rule pch
  command = g++ -MD -MF $out.dep $ccflags -x c++-header -c $in -o $out
  depfile = $out.dep
  deps = gcc
  description = \033[32mHH\033[m $in

rule link
  command = g++ {lnk_flags} {' '.join(['-l'+s for s in libs.split()])} $in -o $out
  description = \033[32mLL\033[m $out

""")

		PCH_DEP = ""
		if pch is not None:
			print(f"build {base}/{pch}.pch.h.gch: pch {pch}")
			PCH_DEP = f" || {base}/{pch}.pch.h.gch"

		# find all files to compile
		obj = []
		glsls = []
		for R,D,F in os.walk('.'):
			for f in fnmatch.filter(F, '*.cc'):
				print(f"build {base}/{f}.o: cc {os.path.join(R, f)}{PCH_DEP}")
				obj.append(f"{base}/{f}.o")
			if shaders:
				for f in fnmatch.filter(F, '*.glsl'):
					name = os.path.basename(f).split('.')[0]
					print(f"build {base}/{f}.cc: gl {os.path.join(R, f)}")
					print(f"  name = {name}")
					print(f"build {base}/{f}.o: cc {base}/{f}.cc")
					obj.append(f"{base}/{f}.o")
					glsls.append(name)
		print(f"build {base}/{target}: link {' '.join(obj)}")

		if not os.path.lexists("shaders.h") and glsls:
			with open("shaders.h", "w") as sf:
				print("// auto-generated by ./build", file=sf);
				for s in glsls:
					print(f"extern const char * {s};", file=sf);

		sys.stdout = stdout


os.system("TERM=dumb ninja")

